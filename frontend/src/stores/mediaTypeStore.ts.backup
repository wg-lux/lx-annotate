import { defineStore } from 'pinia';
import { computed, ref, type ComputedRef } from 'vue';
import { useMediaManagement } from '@/api/mediaManagement';

/* ------------------------------------------------------------------ */
/* Types                                                              */
/* ------------------------------------------------------------------ */

export type MediaType = 'pdf' | 'video' | 'unknown';

export interface MediaItem {
  id: number;
  mediaType: MediaType;
  // For PDFs
  pdfStreamUrl?: string;
  pdfUrl?: string;
  // For Videos  
  videoUrl?: string;
  // Common metadata
  filename?: string;
  fileSize?: number;
  // reportMeta can contain additional media indicators
  reportMeta?: {
    pdfUrl?: string;
    file?: string;
    [key: string]: any;
  };
  // Processing state tracking
  lastStatusCheck?: number;
  isProcessingLocked?: boolean;
  anonymizationStatus?: string;
}

export interface MediaTypeConfig {
  icon: string;
  badgeClass: string;
  displayName: string;
  supportedExtensions: string[];
}

/* ------------------------------------------------------------------ */
/* Store Definition                                                   */
/* ------------------------------------------------------------------ */

export const useMediaTypeStore = defineStore('mediaType', () => {
  
  /* ---------------------------------------------------------------- */
  /* State                                                            */
  /* ---------------------------------------------------------------- */
  
  const currentItem = ref<MediaItem | null>(null);
  const processingLocks = ref<Set<string>>(new Set()); // Track processing locks by "type:id"
  
  /* ---------------------------------------------------------------- */
  /* Media Management Integration                                     */
  /* ---------------------------------------------------------------- */
  
  const { 
    getStatusSafe, 
    startAnonymizationSafe, 
    validateAnonymizationSafe,
    clearAllLocks 
  } = useMediaManagement();
  
  /* ---------------------------------------------------------------- */
  /* Media Type Configuration                                         */
  /* ---------------------------------------------------------------- */
  
  const mediaTypeConfigs: Record<MediaType, MediaTypeConfig> = {
    pdf: {
      icon: 'fas fa-file-pdf text-danger',
      badgeClass: 'bg-danger',
      displayName: 'PDF',
      supportedExtensions: ['.pdf']
    },
    video: {
      icon: 'fas fa-video text-primary', 
      badgeClass: 'bg-primary',
      displayName: 'Video',
      supportedExtensions: ['.mp4', '.avi', '.mov', '.mkv', '.webm']
    },
    unknown: {
      icon: 'fas fa-question-circle text-muted',
      badgeClass: 'bg-secondary',
      displayName: 'Unbekannt',
      supportedExtensions: []
    }
  };

  /* ---------------------------------------------------------------- */
  /* Computed Properties                                              */
  /* ---------------------------------------------------------------- */

  /**
   * Determines the media type of the current item based on available properties
   */
  const currentMediaType: ComputedRef<MediaType> = computed(() => {
    if (!currentItem.value) return 'unknown';
    
    return detectMediaType(currentItem.value);
  });

  /**
   * Whether current item is a PDF
   */
  const isPdf = computed(() => currentMediaType.value === 'pdf');

  /**
   * Whether current item is a video
   */
  const isVideo = computed(() => currentMediaType.value === 'video');

  /**
   * Whether current item has unknown media type
   */
  const isUnknown = computed(() => currentMediaType.value === 'unknown');

  /**
   * Get the appropriate source URL for the current media type
   */
  const currentMediaUrl = computed(() => {
    if (!currentItem.value) return undefined;

    if (isPdf.value) {
      return getPdfUrl(currentItem.value);
    }
    
    if (isVideo.value) {
      return getVideoUrl(currentItem.value);
    }

    return undefined;
  });

  /**
   * Get the configuration for the current media type
   */
  const currentMediaConfig = computed(() => {
    return mediaTypeConfigs[currentMediaType.value];
  });

  /* ---------------------------------------------------------------- */
  /* Methods                                                          */
  /* ---------------------------------------------------------------- */

  /**
   * Detect media type from item properties
   */
  function detectMediaType(item: MediaItem): MediaType {
    // 1. Explicit mediaType property check
    // This has the highest priority
    if (item.mediaType && item.mediaType !== 'unknown') {
      return item.mediaType;
    }
    if (item.mediaType && item.mediaType !== 'unknown') {
      return item.mediaType;
    }

    // 2. Check filename extension (if filename is present)
    if (item.filename) {
      const extension = getFileExtension(item.filename);
      
      for (const [type, config] of Object.entries(mediaTypeConfigs)) {
        if (config.supportedExtensions.includes(extension)) {
          return type as MediaType;
        }
      }
    }

    // 3. Check for specific video indicators (HIGHER PRIORITY)
    if (item.videoUrl) {
      return 'video';
    }

    // 4. Check for specific PDF indicators
    if (item.pdfStreamUrl || item.pdfUrl) {
      return 'pdf';
    }

    // 5. ReportMeta-based detection (with caution)
    if (item.reportMeta) {
      // Video has priority if both are present
      if (item.reportMeta.file && !item.reportMeta.pdfUrl) {
        return 'video';
      }
      if (item.reportMeta.pdfUrl && !item.reportMeta.file) {
        return 'pdf';
      }
    }

    return 'unknown';
  }

  /**
   * Get PDF URL with priority order
   */
  function getPdfUrl(item: MediaItem): string | undefined {
    // Priority order for PDF URL:
    // 1. pdfStreamUrl from item (set by VoPPatientDataSerializer)
    // 2. pdfUrl from reportMeta (legacy fallback)
    // 3. pdfUrl from item
    return item.pdfStreamUrl || 
           item.reportMeta?.pdfUrl || 
           item.pdfUrl;
  }

  /**
   * Get video URL
   */
  function getVideoUrl(item: MediaItem): string | undefined {
    return item.videoUrl;
  }

  /**
   * Get file extension from filename
   */
  function getFileExtension(filename: string): string {
    const lastDot = filename.lastIndexOf('.');
    return lastDot >= 0 ? filename.substring(lastDot).toLowerCase() : '';
  }

  /**
   * Get media type configuration by type
   */
  function getMediaTypeConfig(mediaType: MediaType): MediaTypeConfig {
    return mediaTypeConfigs[mediaType];
  }

  /**
   * Get icon class for media type
   */
  function getMediaTypeIcon(mediaType: MediaType): string {
    return mediaTypeConfigs[mediaType].icon;
  }

  /**
   * Get badge class for media type
   */
  function getMediaTypeBadgeClass(mediaType: MediaType): string {
    return mediaTypeConfigs[mediaType].badgeClass;
  }

  /**
   * Get display name for media type
   */
  function getMediaTypeDisplayName(mediaType: MediaType): string {
    return mediaTypeConfigs[mediaType].displayName;
  }

  /**
   * Set the current item and automatically detect its media type
   */
  function setCurrentItem(item: MediaItem | null): void {
    currentItem.value = item;
  }

  /**
   * Check if a filename has a supported extension for any media type
   */
  function isSupportedFile(filename: string): boolean {
    const extension = getFileExtension(filename);
    
    return Object.values(mediaTypeConfigs).some(config => 
      config.supportedExtensions.includes(extension)
    );
  }

  /**
   * Get media type from filename
   */
  function getMediaTypeFromFilename(filename: string): MediaType {
    const extension = getFileExtension(filename);
    
    for (const [type, config] of Object.entries(mediaTypeConfigs)) {
      if (config.supportedExtensions.includes(extension)) {
        return type as MediaType;
      }
    }
    
    return 'unknown';
  }

  /**
   * Validate if item has required properties for its media type
   */
  function validateMediaItem(item: MediaItem): boolean {
    const mediaType = detectMediaType(item);
    
    switch (mediaType) {
      case 'pdf':
        return !!(item.pdfStreamUrl || item.pdfUrl || item.reportMeta?.pdfUrl);
      case 'video':
        return !!(item.videoUrl || item.reportMeta?.file);
      case 'unknown':
        return false;
      default:
        return false;
    }
  }

  /**
   * Get media information summary for debugging
   */
  function getMediaInfo(item: MediaItem | null = null): object {
    const target = item || currentItem.value;
    if (!target) return { error: 'No item provided' };

    const mediaType = detectMediaType(target);
    const config = getMediaTypeConfig(mediaType);
    const isValid = validateMediaItem(target);
    const mediaUrl = mediaType === 'pdf' ? getPdfUrl(target) : getVideoUrl(target);

    return {
      id: target.id,
      filename: target.filename,
      detectedMediaType: mediaType,
      explicitMediaType: target.mediaType,
      isValid,
      mediaUrl,
      config: {
        displayName: config.displayName,
        icon: config.icon,
        badgeClass: config.badgeClass
      },
      availableUrls: {
        pdfStreamUrl: target.pdfStreamUrl,
        pdfUrl: target.pdfUrl,
        videoUrl: target.videoUrl,
        reportMetaPdfUrl: target.reportMeta?.pdfUrl,
        reportMetaFile: target.reportMeta?.file
      }
    };
  }

  /* ---------------------------------------------------------------- */
  /* Polling Protection Functions                                    */
  /* ---------------------------------------------------------------- */
  
  /**
   * Check if a media item can be safely processed (not locked)
   */
  const canProcessMedia = (fileId: number, mediaType: MediaType): boolean => {
    const lockKey = `${mediaType}:${fileId}`;
    return !processingLocks.value.has(lockKey);
  };
  
  /**
   * Acquire processing lock for media item
   */
  const acquireProcessingLock = (fileId: number, mediaType: MediaType): boolean => {
    const lockKey = `${mediaType}:${fileId}`;
    
    if (processingLocks.value.has(lockKey)) {
      console.warn(`Processing lock already exists for ${lockKey}`);
      return false;
    }
    
    processingLocks.value.add(lockKey);
    console.log(`Acquired processing lock for ${lockKey}`);
    return true;
  };
  
  /**
   * Release processing lock for media item
   */
  const releaseProcessingLock = (fileId: number, mediaType: MediaType): void => {
    const lockKey = `${mediaType}:${fileId}`;
    
    if (processingLocks.value.delete(lockKey)) {
      console.log(`Released processing lock for ${lockKey}`);
    } else {
      console.warn(`No processing lock found to release for ${lockKey}`);
    }
  };
  
  /**
   * Safe status check with polling protection
   */
  const getStatusSafeWithProtection = async (fileId: number, mediaType?: MediaType): Promise<any> => {
    const detectedType = mediaType || (currentItem.value ? detectMediaType(currentItem.value) : 'video');
    
    try {
      const result = await getStatusSafe(fileId, detectedType);
      
      // Update current item if it matches
      if (currentItem.value && currentItem.value.id === fileId) {
        currentItem.value.anonymizationStatus = result?.anonymizationStatus;
        currentItem.value.isProcessingLocked = result?.processing_locked;
        currentItem.value.lastStatusCheck = Date.now();
      }
      
      return result;
    } catch (error: any) {
      console.error(`Status check failed for ${detectedType}:${fileId}:`, error);
      throw error;
    }
  };
  
  /**
   * Safe anonymization start with processing lock
   */
  const startAnonymizationSafeWithProtection = async (fileId: number, mediaType?: MediaType): Promise<any> => {
    const detectedType = mediaType || (currentItem.value ? detectMediaType(currentItem.value) : 'video');
    
    if (!acquireProcessingLock(fileId, detectedType)) {
      throw new Error('Datei wird bereits verarbeitet');
    }
    
    try {
      const result = await startAnonymizationSafe(fileId);
      
      // Update current item if it matches
      if (currentItem.value && currentItem.value.id === fileId) {
        currentItem.value.isProcessingLocked = true;
        currentItem.value.anonymizationStatus = 'processing_anonymization';
      }
      
      return result;
    } catch (error) {
      // Release lock on failure
      releaseProcessingLock(fileId, detectedType);
      throw error;
    }
  };
  
  /**
   * Safe validation with processing coordination
   */
  const validateAnonymizationSafeWithProtection = async (fileId: number, mediaType?: MediaType): Promise<any> => {
    const detectedType = mediaType || (currentItem.value ? detectMediaType(currentItem.value) : 'video');
    
    try {
      const result = await validateAnonymizationSafe(fileId);
      
      // Update current item if it matches
      if (currentItem.value && currentItem.value.id === fileId) {
        currentItem.value.anonymizationStatus = 'validated';
        currentItem.value.isProcessingLocked = false;
      }
      
      // Release any local locks since processing is complete
      releaseProcessingLock(fileId, detectedType);
      
      return result;
    } catch (error: any) {
      console.error(`Validation failed for ${detectedType}:${fileId}:`, error);
      throw error;
    }
  };
  
  /**
   * Emergency function to clear all local locks
   */
  const clearAllLocalLocks = (): void => {
    const clearedCount = processingLocks.value.size;
    processingLocks.value.clear();
    console.log(`Cleared ${clearedCount} local processing locks`);
  };
  
  /**
   * Clear both local and server-side locks
   */
  const clearAllProcessingLocks = async (fileType?: 'video' | 'pdf'): Promise<void> => {
    try {
      // Clear server-side locks
      await clearAllLocks(fileType);
      
      // Clear local locks
      if (fileType) {
        // Clear only specific type
        const locksToRemove = Array.from(processingLocks.value).filter(lock => 
          lock.startsWith(`${fileType}:`)
        );
        locksToRemove.forEach(lock => processingLocks.value.delete(lock));
      } else {
        // Clear all local locks
        clearAllLocalLocks();
      }
      
      console.log('All processing locks cleared successfully');
    } catch (error) {
      console.error('Failed to clear processing locks:', error);
      throw error;
    }
  };

  /* ---------------------------------------------------------------- */
  /* Return Store Interface                                           */
  /* ---------------------------------------------------------------- */

  return {
    // State
    currentItem,
    
    // Computed
    currentMediaType,
    isPdf,
    isVideo, 
    isUnknown,
    currentMediaUrl,
    currentMediaConfig,
  /* ---------------------------------------------------------------- */
  /* Polling Protection Functions                                    */
  /* ---------------------------------------------------------------- */
  
  /**
   * Check if a media item can be safely processed (not locked)
   */
  const canProcessMedia = computed(() => {
    return (fileId: number, mediaType: MediaType) => {
      const lockKey = `${mediaType}:${fileId}`;
      return !processingLocks.value.has(lockKey);
    };
  });
  
  /**
   * Acquire processing lock for media item
   */
  const acquireProcessingLock = (fileId: number, mediaType: MediaType): boolean => {
    const lockKey = `${mediaType}:${fileId}`;
    
    if (processingLocks.value.has(lockKey)) {
      console.warn(`Processing lock already exists for ${lockKey}`);
      return false;
    }
    
    processingLocks.value.add(lockKey);
    console.log(`Acquired processing lock for ${lockKey}`);
    return true;
  };
  
  /**
   * Release processing lock for media item
   */
  const releaseProcessingLock = (fileId: number, mediaType: MediaType): void => {
    const lockKey = `${mediaType}:${fileId}`;
    
    if (processingLocks.value.delete(lockKey)) {
      console.log(`Released processing lock for ${lockKey}`);
    } else {
      console.warn(`No processing lock found to release for ${lockKey}`);
    }
  };
  
  /**
   * Safe status check with polling protection
   */
  const getStatusSafeWithProtection = async (fileId: number, mediaType?: MediaType): Promise<any> => {
    const detectedType = mediaType || (currentItem.value ? detectMediaType(currentItem.value) : 'video');
    
    try {
      const result = await getStatusSafe(fileId, detectedType);
      
      // Update current item if it matches
      if (currentItem.value && currentItem.value.id === fileId) {
        currentItem.value.anonymizationStatus = result?.anonymizationStatus;
        currentItem.value.isProcessingLocked = result?.processing_locked;
        currentItem.value.lastStatusCheck = Date.now();
      }
      
      return result;
    } catch (error: any) {
      console.error(`Status check failed for ${detectedType}:${fileId}:`, error);
      throw error;
    }
  };
  
  /**
   * Safe anonymization start with processing lock
   */
  const startAnonymizationSafeWithProtection = async (fileId: number, mediaType?: MediaType): Promise<any> => {
    const detectedType = mediaType || (currentItem.value ? detectMediaType(currentItem.value) : 'video');
    
    if (!acquireProcessingLock(fileId, detectedType)) {
      throw new Error('Datei wird bereits verarbeitet');
    }
    
    try {
      const result = await startAnonymizationSafe(fileId);
      
      // Update current item if it matches
      if (currentItem.value && currentItem.value.id === fileId) {
        currentItem.value.isProcessingLocked = true;
        currentItem.value.anonymizationStatus = 'processing_anonymization';
      }
      
      return result;
    } catch (error) {
      // Release lock on failure
      releaseProcessingLock(fileId, detectedType);
      throw error;
    }
  };
  
  /**
   * Safe validation with processing coordination
   */
  const validateAnonymizationSafeWithProtection = async (fileId: number, mediaType?: MediaType): Promise<any> => {
    const detectedType = mediaType || (currentItem.value ? detectMediaType(currentItem.value) : 'video');
    
    try {
      const result = await validateAnonymizationSafe(fileId);
      
      // Update current item if it matches
      if (currentItem.value && currentItem.value.id === fileId) {
        currentItem.value.anonymizationStatus = 'validated';
        currentItem.value.isProcessingLocked = false;
      }
      
      // Release any local locks since processing is complete
      releaseProcessingLock(fileId, detectedType);
      
      return result;
    } catch (error: any) {
      console.error(`Validation failed for ${detectedType}:${fileId}:`, error);
      throw error;
    }
  };
  
  /**
   * Emergency function to clear all local locks
   */
  const clearAllLocalLocks = (): void => {
    const clearedCount = processingLocks.value.size;
    processingLocks.value.clear();
    console.log(`Cleared ${clearedCount} local processing locks`);
  };
  
  /**
   * Clear both local and server-side locks
   */
  const clearAllProcessingLocks = async (fileType?: 'video' | 'pdf'): Promise<void> => {
    try {
      // Clear server-side locks
      await clearAllLocks(fileType);
      
      // Clear local locks
      if (fileType) {
        // Clear only specific type
        const locksToRemove = Array.from(processingLocks.value).filter(lock => 
          lock.startsWith(`${fileType}:`)
        );
        locksToRemove.forEach(lock => processingLocks.value.delete(lock));
      } else {
        // Clear all local locks
        clearAllLocalLocks();
      }
      
      console.log('All processing locks cleared successfully');
    } catch (error) {
      console.error('Failed to clear processing locks:', error);
      throw error;
    }
  };
  
  /* ---------------------------------------------------------------- */
  /* Return Statement                                                 */
  /* ---------------------------------------------------------------- */
  
  return {
    // Existing state
    currentItem: computed(() => currentItem.value),
    processingLocks: computed(() => Array.from(processingLocks.value)),
    
    // Existing methods
    detectMediaType,
    getPdfUrl,
    getVideoUrl,
    getMediaTypeConfig,
    getMediaTypeIcon,
    getMediaTypeBadgeClass,
    getMediaTypeDisplayName,
    setCurrentItem,
    isSupportedFile,
    getMediaTypeFromFilename,
    validateMediaItem,
    getMediaInfo,
    
    // New polling protection methods
    canProcessMedia,
    acquireProcessingLock,
    releaseProcessingLock,
    getStatusSafeWithProtection,
    startAnonymizationSafeWithProtection,
    validateAnonymizationSafeWithProtection,
    clearAllLocalLocks,
    clearAllProcessingLocks,
    
    // Constants
    mediaTypeConfigs
  };
});

/* ------------------------------------------------------------------ */
/* Utility Functions (can be used outside store)                     */
/* ------------------------------------------------------------------ */

/**
 * Standalone function to detect media type without store context
 */
export function detectMediaTypeStandalone(item: MediaItem): MediaType {
  // Check for explicit mediaType property first
  if (item.mediaType && item.mediaType !== 'unknown') {
    return item.mediaType;
  }

  // Check for PDF indicators
  if (item.pdfStreamUrl || item.pdfUrl || item.reportMeta?.pdfUrl) {
    return 'pdf';
  }

  // Check for video indicators  
  if (item.videoUrl || item.reportMeta?.file) {
    return 'video';
  }

  return 'unknown';
}

/**
 * Standalone function to get appropriate CSS classes
 */
export function getMediaTypeClasses(mediaType: MediaType): { icon: string; badge: string } {
  const configs: Record<MediaType, { icon: string; badge: string }> = {
    pdf: { icon: 'fas fa-file-pdf text-danger', badge: 'bg-danger' },
    video: { icon: 'fas fa-video text-primary', badge: 'bg-primary' },
    unknown: { icon: 'fas fa-question-circle text-muted', badge: 'bg-secondary' }
  };
  
  return configs[mediaType];
}
